{:arglists ([& options]), :doc "Generic, reusable, read-eval-print loop. By default, reads from *in*,\n  writes to *out*, and prints exception summaries to *err*. If you use the\n  default :read hook, *in* must either be an instance of\n  LineNumberingPushbackReader or duplicate its behavior of both supporting\n  .unread and collapsing CR, LF, and CRLF into a single \\newline. Options\n  are sequential keyword-value pairs. Available options and their defaults:\n\n     - :init, function of no arguments, initialization hook called with\n       bindings for set!-able vars in place.\n       default: #()\n\n     - :need-prompt, function of no arguments, called before each\n       read-eval-print except the first, the user will be prompted if it\n       returns true.\n       default: (if (instance? LineNumberingPushbackReader *in*)\n                  #(.atLineStart *in*)\n                  #(identity true))\n\n     - :prompt, function of no arguments, prompts for more input.\n       default: repl-prompt\n\n     - :flush, function of no arguments, flushes output\n       default: flush\n\n     - :read, function of two arguments, reads from *in*:\n         - returns its first argument to request a fresh prompt\n           - depending on need-prompt, this may cause the repl to prompt\n             before reading again\n         - returns its second argument to request an exit from the repl\n         - else returns the next object read from the input stream\n       default: repl-read\n\n     - :eval, function of one argument, returns the evaluation of its\n       argument\n       default: eval\n\n     - :print, function of one argument, prints its argument to the output\n       default: prn\n\n     - :caught, function of one argument, a throwable, called when\n       read, eval, or print throws an exception or error\n       default: repl-caught", :line 174, :column 1, :file "clojure/main.clj", :name "repl", :ns "clojure.main", :src "(defn repl\n  \"Generic, reusable, read-eval-print loop. By default, reads from *in*,\n  writes to *out*, and prints exception summaries to *err*. If you use the\n  default :read hook, *in* must either be an instance of\n  LineNumberingPushbackReader or duplicate its behavior of both supporting\n  .unread and collapsing CR, LF, and CRLF into a single \\\\newline. Options\n  are sequential keyword-value pairs. Available options and their defaults:\n\n     - :init, function of no arguments, initialization hook called with\n       bindings for set!-able vars in place.\n       default: #()\n\n     - :need-prompt, function of no arguments, called before each\n       read-eval-print except the first, the user will be prompted if it\n       returns true.\n       default: (if (instance? LineNumberingPushbackReader *in*)\n                  #(.atLineStart *in*)\n                  #(identity true))\n\n     - :prompt, function of no arguments, prompts for more input.\n       default: repl-prompt\n\n     - :flush, function of no arguments, flushes output\n       default: flush\n\n     - :read, function of two arguments, reads from *in*:\n         - returns its first argument to request a fresh prompt\n           - depending on need-prompt, this may cause the repl to prompt\n             before reading again\n         - returns its second argument to request an exit from the repl\n         - else returns the next object read from the input stream\n       default: repl-read\n\n     - :eval, function of one argument, returns the evaluation of its\n       argument\n       default: eval\n\n     - :print, function of one argument, prints its argument to the output\n       default: prn\n\n     - :caught, function of one argument, a throwable, called when\n       read, eval, or print throws an exception or error\n       default: repl-caught\"\n  [& options]\n  (let [cl (.getContextClassLoader (Thread/currentThread))]\n    (.setContextClassLoader (Thread/currentThread) (clojure.lang.DynamicClassLoader. cl)))\n  (let [{:keys [init need-prompt prompt flush read eval print caught]\n         :or {init        #()\n              need-prompt (if (instance? LineNumberingPushbackReader *in*)\n                            #(.atLineStart ^LineNumberingPushbackReader *in*)\n                            #(identity true))\n              prompt      repl-prompt\n              flush       flush\n              read        repl-read\n              eval        eval\n              print       prn\n              caught      repl-caught}}\n        (apply hash-map options)\n        request-prompt (Object.)\n        request-exit (Object.)\n        read-eval-print\n        (fn []\n          (try\n            (let [read-eval *read-eval*\n                  input (with-read-known (read request-prompt request-exit))]\n             (or (#{request-prompt request-exit} input)\n                 (let [value (binding [*read-eval* read-eval] (eval input))]\n                   (print value)\n                   (set! *3 *2)\n                   (set! *2 *1)\n                   (set! *1 value))))\n           (catch Throwable e\n             (caught e)\n             (set! *e e))))]\n    (with-bindings\n     (try\n      (init)\n      (catch Throwable e\n        (caught e)\n        (set! *e e)))\n     (prompt)\n     (flush)\n     (loop []\n       (when-not \n       \t (try (identical? (read-eval-print) request-exit)\n\t  (catch Throwable e\n\t   (caught e)\n\t   (set! *e e)\n\t   nil))\n         (when (need-prompt)\n           (prompt)\n           (flush))\n         (recur))))))", :type :fn}