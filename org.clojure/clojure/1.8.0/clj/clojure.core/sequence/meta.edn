{:added "1.0", :ns "clojure.core", :name "sequence", :file "clojure/core.clj", :static true, :type :fn, :src "(defn sequence\n  \"Coerces coll to a (possibly empty) sequence, if it is not already\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\n  transducer is supplied, returns a lazy sequence of applications of\n  the transform to the items in coll(s), i.e. to the set of first\n  items of each coll, followed by the set of second\n  items in each coll, until any one of the colls is exhausted.  Any\n  remaining items in other colls are ignored. The transform should accept\n  number-of-colls arguments\"\n  {:added \"1.0\"\n   :static true}\n  ([coll]\n     (if (seq? coll) coll\n         (or (seq coll) ())))\n  ([xform coll]\n     (or (clojure.lang.RT/chunkIteratorSeq\n         (clojure.lang.TransformerIterator/create xform (clojure.lang.RT/iter coll)))\n       ()))\n  ([xform coll & colls]\n     (or (clojure.lang.RT/chunkIteratorSeq\n         (clojure.lang.TransformerIterator/createMulti\n           xform\n           (map #(clojure.lang.RT/iter %) (cons coll colls))))\n       ())))", :column 1, :line 2538, :arglists ([coll] [xform coll] [xform coll & colls]), :doc "Coerces coll to a (possibly empty) sequence, if it is not already\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\n  transducer is supplied, returns a lazy sequence of applications of\n  the transform to the items in coll(s), i.e. to the set of first\n  items of each coll, followed by the set of second\n  items in each coll, until any one of the colls is exhausted.  Any\n  remaining items in other colls are ignored. The transform should accept\n  number-of-colls arguments"}