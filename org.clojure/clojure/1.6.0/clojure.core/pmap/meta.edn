{:added "1.0", :ns "clojure.core", :name "pmap", :file "clojure/core.clj", :static true, :type :fn, :src "(defn pmap\n  \"Like map, except f is applied in parallel. Semi-lazy in that the\n  parallel computation stays ahead of the consumption, but doesn't\n  realize the entire result unless required. Only useful for\n  computationally intensive functions where the time of f dominates\n  the coordination overhead.\"\n  {:added \"1.0\"\n   :static true}\n  ([f coll]\n   (let [n (+ 2 (.. Runtime getRuntime availableProcessors))\n         rets (map #(future (f %)) coll)\n         step (fn step [[x & xs :as vs] fs]\n                (lazy-seq\n                 (if-let [s (seq fs)]\n                   (cons (deref x) (step xs (rest s)))\n                   (map deref vs))))]\n     (step rets (drop n rets))))\n  ([f coll & colls]\n   (let [step (fn step [cs]\n                (lazy-seq\n                 (let [ss (map seq cs)]\n                   (when (every? identity ss)\n                     (cons (map first ss) (step (map rest ss)))))))]\n     (pmap #(apply f %) (step (cons coll colls))))))", :column 1, :line 6456, :arglists ([f coll] [f coll & colls]), :doc "Like map, except f is applied in parallel. Semi-lazy in that the\n  parallel computation stays ahead of the consumption, but doesn't\n  realize the entire result unless required. Only useful for\n  computationally intensive functions where the time of f dominates\n  the coordination overhead."}