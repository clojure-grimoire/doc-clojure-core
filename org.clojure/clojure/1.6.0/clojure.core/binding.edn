{:added "1.0", :ns "clojure.core", :name "binding", :file "clojure/core.clj", :type :macro, :src "(defmacro binding\n  \"binding => var-symbol init-expr\n\n  Creates new bindings for the (already-existing) vars, with the\n  supplied initial values, executes the exprs in an implicit do, then\n  re-establishes the bindings that existed before.  The new bindings\n  are made in parallel (unlike let); all init-exprs are evaluated\n  before the vars are bound to their new values.\"\n  {:added \"1.0\"}\n  [bindings & body]\n  (assert-args\n    (vector? bindings) \"a vector for its binding\"\n    (even? (count bindings)) \"an even number of forms in binding vector\")\n  (let [var-ize (fn [var-vals]\n                  (loop [ret [] vvs (seq var-vals)]\n                    (if vvs\n                      (recur  (conj (conj ret `(var ~(first vvs))) (second vvs))\n                             (next (next vvs)))\n                      (seq ret))))]\n    `(let []\n       (push-thread-bindings (hash-map ~@(var-ize bindings)))\n       (try\n         ~@body\n         (finally\n           (pop-thread-bindings))))))", :column 1, :line 1827, :macro true, :arglists ([bindings & body]), :doc "binding => var-symbol init-expr\n\n  Creates new bindings for the (already-existing) vars, with the\n  supplied initial values, executes the exprs in an implicit do, then\n  re-establishes the bindings that existed before.  The new bindings\n  are made in parallel (unlike let); all init-exprs are evaluated\n  before the vars are bound to their new values."}