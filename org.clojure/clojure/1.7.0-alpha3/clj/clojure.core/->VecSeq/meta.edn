{:type :fn, :src "(deftype VecSeq [^clojure.core.ArrayManager am ^clojure.core.IVecImpl vec anode ^int i ^int offset] \n  :no-print true\n\n  clojure.core.protocols.InternalReduce\n  (internal-reduce\n   [_ f val]\n   (loop [result val\n          aidx (+ i offset)]\n     (if (< aidx (count vec))\n       (let [node (.arrayFor vec aidx)\n             result (loop [result result\n                           node-idx (bit-and 0x1f aidx)]\n                      (if (< node-idx (.alength am node))\n                        (recur (f result (.aget am node node-idx)) (inc node-idx))\n                        result))]\n         (recur result (bit-and 0xffe0 (+ aidx 32))))\n       result)))\n  \n  clojure.lang.ISeq\n  (first [_] (.aget am anode offset))\n  (next [this] \n    (if (< (inc offset) (.alength am anode))\n      (new VecSeq am vec anode i (inc offset))\n      (.chunkedNext this)))\n  (more [this]\n    (let [s (.next this)]\n      (or s (clojure.lang.PersistentList/EMPTY))))\n  (cons [this o]\n    (clojure.lang.Cons. o this))\n  (count [this]\n    (loop [i 1\n           s (next this)]\n      (if s\n        (if (instance? clojure.lang.Counted s)\n          (+ i (.count s))\n          (recur (inc i) (next s)))\n        i)))\n  (equiv [this o]\n    (cond\n     (identical? this o) true\n     (or (instance? clojure.lang.Sequential o) (instance? java.util.List o))\n     (loop [me this\n            you (seq o)]\n       (if (nil? me)\n         (nil? you)\n         (and (clojure.lang.Util/equiv (first me) (first you))\n              (recur (next me) (next you)))))\n     :else false))\n  (empty [_]\n    clojure.lang.PersistentList/EMPTY)\n\n\n  clojure.lang.Seqable\n  (seq [this] this)\n\n  clojure.lang.IChunkedSeq\n  (chunkedFirst [_] (ArrayChunk. am anode offset (.alength am anode)))\n  (chunkedNext [_] \n   (let [nexti (+ i (.alength am anode))]\n     (when (< nexti (count vec))\n       (new VecSeq am vec (.arrayFor vec nexti) nexti 0))))\n  (chunkedMore [this]\n    (let [s (.chunkedNext this)]\n      (or s (clojure.lang.PersistentList/EMPTY)))))", :ns "clojure.core", :name "->VecSeq", :file "clojure/gvec.clj", :column 1, :line 56, :arglists ([am vec anode i offset]), :doc "Positional factory function for class clojure.core.VecSeq."}