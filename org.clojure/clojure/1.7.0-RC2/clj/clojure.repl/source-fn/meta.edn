{:arglists ([x]), :doc "Returns a string of the source code for the given symbol, if it can\n  find it.  This requires that the symbol resolve to a Var defined in\n  a namespace for which the .clj is in the classpath.  Returns nil if\n  it can't find the source.  For most REPL usage, 'source' is more\n  convenient.\n\n  Example: (source-fn 'filter)", :line 134, :column 1, :file "clojure/repl.clj", :name "source-fn", :ns "clojure.repl", :src "(defn source-fn\n  \"Returns a string of the source code for the given symbol, if it can\n  find it.  This requires that the symbol resolve to a Var defined in\n  a namespace for which the .clj is in the classpath.  Returns nil if\n  it can't find the source.  For most REPL usage, 'source' is more\n  convenient.\n\n  Example: (source-fn 'filter)\"\n  [x]\n  (when-let [v (resolve x)]\n    (when-let [filepath (:file (meta v))]\n      (when-let [strm (.getResourceAsStream (RT/baseLoader) filepath)]\n        (with-open [rdr (LineNumberReader. (InputStreamReader. strm))]\n          (dotimes [_ (dec (:line (meta v)))] (.readLine rdr))\n          (let [text (StringBuilder.)\n                pbr (proxy [PushbackReader] [rdr]\n                      (read [] (let [i (proxy-super read)]\n                                 (.append text (char i))\n                                 i)))\n                read-opts (if (.endsWith ^String filepath \"cljc\") {:read-cond :allow} {})]\n            (if (= :unknown *read-eval*)\n              (throw (IllegalStateException. \"Unable to read source while *read-eval* is :unknown.\"))\n              (read read-opts (PushbackReader. pbr)))\n            (str text)))))))", :type :fn}