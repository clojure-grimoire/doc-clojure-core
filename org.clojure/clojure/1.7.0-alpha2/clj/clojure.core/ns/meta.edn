{:added "1.0", :ns "clojure.core", :name "ns", :file "clojure/core.clj", :type :macro, :src "(defmacro ns\n  \"Sets *ns* to the namespace named by name (unevaluated), creating it\n  if needed.  references can be zero or more of: (:refer-clojure ...)\n  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)\n  with the syntax of refer-clojure/require/use/import/load/gen-class\n  respectively, except the arguments are unevaluated and need not be\n  quoted. (:gen-class ...), when supplied, defaults to :name\n  corresponding to the ns name, :main true, :impl-ns same as ns, and\n  :init-impl-ns true. All options of gen-class are\n  supported. The :gen-class directive is ignored when not\n  compiling. If :gen-class is not supplied, when compiled only an\n  nsname__init.class will be generated. If :refer-clojure is not used, a\n  default (refer 'clojure.core) is used.  Use of ns is preferred to\n  individual calls to in-ns/require/use/import:\n\n  (ns foo.bar\n    (:refer-clojure :exclude [ancestors printf])\n    (:require (clojure.contrib sql combinatorics))\n    (:use (my.lib this that))\n    (:import (java.util Date Timer Random)\n             (java.sql Connection Statement)))\"\n  {:arglists '([name docstring? attr-map? references*])\n   :added \"1.0\"}\n  [name & references]\n  (let [process-reference\n        (fn [[kname & args]]\n          `(~(symbol \"clojure.core\" (clojure.core/name kname))\n             ~@(map #(list 'quote %) args)))\n        docstring  (when (string? (first references)) (first references))\n        references (if docstring (next references) references)\n        name (if docstring\n               (vary-meta name assoc :doc docstring)\n               name)\n        metadata   (when (map? (first references)) (first references))\n        references (if metadata (next references) references)\n        name (if metadata\n               (vary-meta name merge metadata)\n               name)\n        gen-class-clause (first (filter #(= :gen-class (first %)) references))\n        gen-class-call\n          (when gen-class-clause\n            (list* `gen-class :name (.replace (str name) \\- \\_) :impl-ns name :main true (next gen-class-clause)))\n        references (remove #(= :gen-class (first %)) references)\n        ;ns-effect (clojure.core/in-ns name)\n        ]\n    `(do\n       (clojure.core/in-ns '~name)\n       (with-loading-context\n        ~@(when gen-class-call (list gen-class-call))\n        ~@(when (and (not= name 'clojure.core) (not-any? #(= :refer-clojure (first %)) references))\n            `((clojure.core/refer '~'clojure.core)))\n        ~@(map process-reference references))\n        (if (.equals '~name 'clojure.core) \n          nil\n          (do (dosync (commute @#'*loaded-libs* conj '~name)) nil)))))", :column 1, :line 5459, :macro true, :arglists ([name docstring? attr-map? references*]), :doc "Sets *ns* to the namespace named by name (unevaluated), creating it\n  if needed.  references can be zero or more of: (:refer-clojure ...)\n  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)\n  with the syntax of refer-clojure/require/use/import/load/gen-class\n  respectively, except the arguments are unevaluated and need not be\n  quoted. (:gen-class ...), when supplied, defaults to :name\n  corresponding to the ns name, :main true, :impl-ns same as ns, and\n  :init-impl-ns true. All options of gen-class are\n  supported. The :gen-class directive is ignored when not\n  compiling. If :gen-class is not supplied, when compiled only an\n  nsname__init.class will be generated. If :refer-clojure is not used, a\n  default (refer 'clojure.core) is used.  Use of ns is preferred to\n  individual calls to in-ns/require/use/import:\n\n  (ns foo.bar\n    (:refer-clojure :exclude [ancestors printf])\n    (:require (clojure.contrib sql combinatorics))\n    (:use (my.lib this that))\n    (:import (java.util Date Timer Random)\n             (java.sql Connection Statement)))"}