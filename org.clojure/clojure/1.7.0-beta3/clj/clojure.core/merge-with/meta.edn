{:added "1.0", :ns "clojure.core", :name "merge-with", :file "clojure/core.clj", :static true, :type :fn, :src "(defn merge-with\n  \"Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping(s)\n  from the latter (left-to-right) will be combined with the mapping in\n  the result by calling (f val-in-result val-in-latter).\"\n  {:added \"1.0\"\n   :static true}\n  [f & maps]\n  (when (some identity maps)\n    (let [merge-entry (fn [m e]\n\t\t\t(let [k (key e) v (val e)]\n\t\t\t  (if (contains? m k)\n\t\t\t    (assoc m k (f (get m k) v))\n\t\t\t    (assoc m k v))))\n          merge2 (fn [m1 m2]\n\t\t   (reduce1 merge-entry (or m1 {}) (seq m2)))]\n      (reduce1 merge2 maps))))", :column 1, :line 2918, :arglists ([f & maps]), :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping(s)\n  from the latter (left-to-right) will be combined with the mapping in\n  the result by calling (f val-in-result val-in-latter)."}