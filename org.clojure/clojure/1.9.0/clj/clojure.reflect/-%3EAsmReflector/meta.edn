{:ns #object[clojure.lang.Namespace 0x6572bcb5 "clojure.reflect"], :name "->AsmReflector", :file "clojure/reflect/java.clj", :type :fn, :src "(deftype AsmReflector [class-resolver]\n  Reflector\n  (do-reflect [_ typeref]\n    (with-open [is (resolve-class class-resolver typeref)]\n      (let [class-symbol (typesym typeref)\n            r (ClassReader. is)\n            result (atom {:bases #{} :flags #{} :members #{}})]\n        (.accept\n         r\n         (proxy\n          [ClassVisitor]\n          [Opcodes/ASM4]\n          (visit [version access name signature superName interfaces]\n                 (let [flags (parse-flags access :class)\n                       ;; ignore java.lang.Object on interfaces to match reflection\n                       superName (if (and (flags :interface)\n                                          (= superName \"java/lang/Object\"))\n                                   nil\n                                   superName)\n                       bases (->> (cons superName interfaces)\n                                  (remove nil?)\n                                  (map internal-name->class-symbol)\n                                  (map symbol)\n                                  (set)\n                                  (not-empty))]\n                   (swap! result merge {:bases bases \n                                        :flags flags})))\n          (visitAnnotation [desc visible])\n          (visitSource [name debug])\n          (visitInnerClass [name outerName innerName access])\n          (visitField [access name desc signature value]\n                      (swap! result update :members (fnil conj #{})\n                             (Field. (symbol name)\n                                     (field-descriptor->class-symbol desc)\n                                     class-symbol\n                                     (parse-flags access :field)))\n                      nil)\n          (visitMethod [access name desc signature exceptions]\n                       (when-not (= name \"<clinit>\")\n                         (let [constructor? (= name \"<init>\")]\n                           (swap! result update :members (fnil conj #{})\n                                  (let [{:keys [parameter-types return-type]} (parse-method-descriptor desc)\n                                        flags (parse-flags access :method)]\n                                    (if constructor?\n                                      (Constructor. class-symbol\n                                                    class-symbol\n                                                    parameter-types\n                                                    (vec (map internal-name->class-symbol exceptions))\n                                                    flags)\n                                      (Method. (symbol name)\n                                               return-type\n                                               class-symbol\n                                               parameter-types\n                                               (vec (map internal-name->class-symbol exceptions))\n                                               flags))))))\n                       nil)\n          (visitEnd [])\n          ) 0)\n        @result))))", :column 1, :line 196, :arglists ([class-resolver]), :doc "Positional factory function for class clojure.reflect.AsmReflector.", :namespace "clojure.reflect"}