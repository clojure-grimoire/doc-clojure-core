{:ns #object[clojure.lang.Namespace 0x1ee98d0d "clojure.main"], :name "skip-whitespace", :file "clojure/main.clj", :type :fn, :src "(defn skip-whitespace\n  \"Skips whitespace characters on stream s. Returns :line-start, :stream-end,\n  or :body to indicate the relative location of the next character on s.\n  Interprets comma as whitespace and semicolon as comment to end of line.\n  Does not interpret #! as comment to end of line because only one\n  character of lookahead is available. The stream must either be an\n  instance of LineNumberingPushbackReader or duplicate its behavior of both\n  supporting .unread and collapsing all of CR, LF, and CRLF to a single\n  \\\\newline.\"\n  [s]\n  (loop [c (.read s)]\n    (cond\n     (= c (int \\newline)) :line-start\n     (= c -1) :stream-end\n     (= c (int \\;)) (do (.readLine s) :line-start)\n     (or (Character/isWhitespace (char c)) (= c (int \\,))) (recur (.read s))\n     :else (do (.unread s c) :body))))", :column 1, :line 111, :arglists ([s]), :doc "Skips whitespace characters on stream s. Returns :line-start, :stream-end,\n  or :body to indicate the relative location of the next character on s.\n  Interprets comma as whitespace and semicolon as comment to end of line.\n  Does not interpret #! as comment to end of line because only one\n  character of lookahead is available. The stream must either be an\n  instance of LineNumberingPushbackReader or duplicate its behavior of both\n  supporting .unread and collapsing all of CR, LF, and CRLF to a single\n  \\newline.", :namespace "clojure.main"}