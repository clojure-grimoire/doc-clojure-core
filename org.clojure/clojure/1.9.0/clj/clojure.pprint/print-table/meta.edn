{:added "1.3", :ns #object[clojure.lang.Namespace 0x3de08050 "clojure.pprint"], :name "print-table", :file "clojure/pprint/print_table.clj", :type :fn, :src "(defn print-table\n  \"Prints a collection of maps in a textual table. Prints table headings\n   ks, and then a line of output for each row, corresponding to the keys\n   in ks. If ks are not specified, use the keys of the first item in rows.\"\n  {:added \"1.3\"}\n  ([ks rows]\n     (when (seq rows)\n       (let [widths (map\n                     (fn [k]\n                       (apply max (count (str k)) (map #(count (str (get % k))) rows)))\n                     ks)\n             spacers (map #(apply str (repeat % \"-\")) widths)\n             fmts (map #(str \"%\" % \"s\") widths)\n             fmt-row (fn [leader divider trailer row]\n                       (str leader\n                            (apply str (interpose divider\n                                                  (for [[col fmt] (map vector (map #(get row %) ks) fmts)]\n                                                    (format fmt (str col)))))\n                            trailer))]\n         (println)\n         (println (fmt-row \"| \" \" | \" \" |\" (zipmap ks ks)))\n         (println (fmt-row \"|-\" \"-+-\" \"-|\" (zipmap ks spacers)))\n         (doseq [row rows]\n           (println (fmt-row \"| \" \" | \" \" |\" row))))))\n  ([rows] (print-table (keys (first rows)) rows)))", :column 1, :line 11, :arglists ([ks rows] [rows]), :doc "Prints a collection of maps in a textual table. Prints table headings\n   ks, and then a line of output for each row, corresponding to the keys\n   in ks. If ks are not specified, use the keys of the first item in rows.", :namespace "clojure.pprint"}