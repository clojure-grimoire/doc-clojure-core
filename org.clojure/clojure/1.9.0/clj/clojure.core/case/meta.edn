{:added "1.2", :ns #object[clojure.lang.Namespace 0x264888e7 "clojure.core"], :name "case", :file "clojure/core.clj", :type :macro, :src "(defmacro case \n  \"Takes an expression, and a set of clauses.\n\n  Each clause can take the form of either:\n\n  test-constant result-expr\n\n  (test-constant1 ... test-constantN)  result-expr\n\n  The test-constants are not evaluated. They must be compile-time\n  literals, and need not be quoted.  If the expression is equal to a\n  test-constant, the corresponding result-expr is returned. A single\n  default expression can follow the clauses, and its value will be\n  returned if no clause matches. If no default expression is provided\n  and no clause matches, an IllegalArgumentException is thrown.\n\n  Unlike cond and condp, case does a constant-time dispatch, the\n  clauses are not considered sequentially.  All manner of constant\n  expressions are acceptable in case, including numbers, strings,\n  symbols, keywords, and (Clojure) composites thereof. Note that since\n  lists are used to group multiple constants that map to the same\n  expression, a vector can be used to match a list if needed. The\n  test-constants need not be all of the same type.\"\n  {:added \"1.2\"}\n\n  [e & clauses]\n  (let [ge (with-meta (gensym) {:tag Object})\n        default (if (odd? (count clauses)) \n                  (last clauses)\n                  `(throw (IllegalArgumentException. (str \"No matching clause: \" ~ge))))]\n    (if (> 2 (count clauses))\n      `(let [~ge ~e] ~default)\n      (let [pairs (partition 2 clauses)\n            assoc-test (fn assoc-test [m test expr]\n                         (if (contains? m test)\n                           (throw (IllegalArgumentException. (str \"Duplicate case test constant: \" test)))\n                           (assoc m test expr)))\n            pairs (reduce1\n                       (fn [m [test expr]]\n                         (if (seq? test)\n                           (reduce1 #(assoc-test %1 %2 expr) m test)\n                           (assoc-test m test expr)))\n                       {} pairs)\n            tests (keys pairs)\n            thens (vals pairs)\n            mode (cond\n                   (every? #(and (integer? %) (<= Integer/MIN_VALUE % Integer/MAX_VALUE)) tests)\n                   :ints\n                   (every? keyword? tests)\n                   :identity\n                   :else :hashes)]\n        (condp = mode\n          :ints\n          (let [[shift mask imap switch-type] (prep-ints tests thens)]\n            `(let [~ge ~e] (case* ~ge ~shift ~mask ~default ~imap ~switch-type :int)))\n          :hashes\n          (let [[shift mask imap switch-type skip-check] (prep-hashes ge default tests thens)]\n            `(let [~ge ~e] (case* ~ge ~shift ~mask ~default ~imap ~switch-type :hash-equiv ~skip-check)))\n          :identity\n          (let [[shift mask imap switch-type skip-check] (prep-hashes ge default tests thens)]\n            `(let [~ge ~e] (case* ~ge ~shift ~mask ~default ~imap ~switch-type :hash-identity ~skip-check))))))))", :column 1, :line 6617, :macro true, :arglists ([e & clauses]), :doc "Takes an expression, and a set of clauses.\n\n  Each clause can take the form of either:\n\n  test-constant result-expr\n\n  (test-constant1 ... test-constantN)  result-expr\n\n  The test-constants are not evaluated. They must be compile-time\n  literals, and need not be quoted.  If the expression is equal to a\n  test-constant, the corresponding result-expr is returned. A single\n  default expression can follow the clauses, and its value will be\n  returned if no clause matches. If no default expression is provided\n  and no clause matches, an IllegalArgumentException is thrown.\n\n  Unlike cond and condp, case does a constant-time dispatch, the\n  clauses are not considered sequentially.  All manner of constant\n  expressions are acceptable in case, including numbers, strings,\n  symbols, keywords, and (Clojure) composites thereof. Note that since\n  lists are used to group multiple constants that map to the same\n  expression, a vector can be used to match a list if needed. The\n  test-constants need not be all of the same type.", :namespace "clojure.core"}