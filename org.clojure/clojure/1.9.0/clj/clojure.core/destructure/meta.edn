{:arglists ([bindings]), :line 4355, :column 1, :file "clojure/core.clj", :name "destructure", :ns #object[clojure.lang.Namespace 0x264888e7 "clojure.core"], :src "(defn destructure [bindings]\n  (let [bents (partition 2 bindings)\n        pb (fn pb [bvec b v]\n             (let [pvec\n                   (fn [bvec b val]\n                     (let [gvec (gensym \"vec__\")\n                           gseq (gensym \"seq__\")\n                           gfirst (gensym \"first__\")\n                           has-rest (some #{'&} b)]\n                       (loop [ret (let [ret (conj bvec gvec val)]\n                                    (if has-rest\n                                      (conj ret gseq (list `seq gvec))\n                                      ret))\n                              n 0\n                              bs b\n                              seen-rest? false]\n                         (if (seq bs)\n                           (let [firstb (first bs)]\n                             (cond\n                              (= firstb '&) (recur (pb ret (second bs) gseq)\n                                                   n\n                                                   (nnext bs)\n                                                   true)\n                              (= firstb :as) (pb ret (second bs) gvec)\n                              :else (if seen-rest?\n                                      (throw (new Exception \"Unsupported binding form, only :as can follow & parameter\"))\n                                      (recur (pb (if has-rest\n                                                   (conj ret\n                                                         gfirst `(first ~gseq)\n                                                         gseq `(next ~gseq))\n                                                   ret)\n                                                 firstb\n                                                 (if has-rest\n                                                   gfirst\n                                                   (list `nth gvec n nil)))\n                                             (inc n)\n                                             (next bs)\n                                             seen-rest?))))\n                           ret))))\n                   pmap\n                   (fn [bvec b v]\n                     (let [gmap (gensym \"map__\")\n                           gmapseq (with-meta gmap {:tag 'clojure.lang.ISeq})\n                           defaults (:or b)]\n                       (loop [ret (-> bvec (conj gmap) (conj v)\n                                      (conj gmap) (conj `(if (seq? ~gmap) (clojure.lang.PersistentHashMap/create (seq ~gmapseq)) ~gmap))\n                                      ((fn [ret]\n                                         (if (:as b)\n                                           (conj ret (:as b) gmap)\n                                           ret))))\n                              bes (let [transforms\n                                          (reduce1\n                                            (fn [transforms mk]\n                                              (if (keyword? mk)\n                                                (let [mkns (namespace mk)\n                                                      mkn (name mk)]\n                                                  (cond (= mkn \"keys\") (assoc transforms mk #(keyword (or mkns (namespace %)) (name %)))\n                                                        (= mkn \"syms\") (assoc transforms mk #(list `quote (symbol (or mkns (namespace %)) (name %))))\n                                                        (= mkn \"strs\") (assoc transforms mk str)\n                                                        :else transforms))\n                                                transforms))\n                                            {}\n                                            (keys b))]\n                                    (reduce1\n                                        (fn [bes entry]\n                                          (reduce1 #(assoc %1 %2 ((val entry) %2))\n                                                   (dissoc bes (key entry))\n                                                   ((key entry) bes)))\n                                        (dissoc b :as :or)\n                                        transforms))]\n                         (if (seq bes)\n                           (let [bb (key (first bes))\n                                 bk (val (first bes))\n                                 local (if (instance? clojure.lang.Named bb) (with-meta (symbol nil (name bb)) (meta bb)) bb)\n                                 bv (if (contains? defaults local)\n                                      (list `get gmap bk (defaults local))\n                                      (list `get gmap bk))]\n                             (recur (if (ident? bb)\n                                      (-> ret (conj local bv))\n                                      (pb ret bb bv))\n                                    (next bes)))\n                           ret))))]\n               (cond\n                (symbol? b) (-> bvec (conj b) (conj v))\n                (vector? b) (pvec bvec b v)\n                (map? b) (pmap bvec b v)\n                :else (throw (new Exception (str \"Unsupported binding form: \" b))))))\n        process-entry (fn [bvec b] (pb bvec (first b) (second b)))]\n    (if (every? symbol? (map first bents))\n      bindings\n      (reduce1 process-entry [] bents))))", :type :fn, :namespace "clojure.core"}