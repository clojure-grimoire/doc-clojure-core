{:added "1.0", :ns #object[clojure.lang.Namespace 0x264888e7 "clojure.core"], :name "partition", :file "clojure/core.clj", :static true, :type :fn, :src "(defn partition\n  \"Returns a lazy sequence of lists of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition upto n items. In case there are\n  not enough padding elements, return a partition with less than n items.\"\n  {:added \"1.0\"\n   :static true}\n  ([n coll]\n     (partition n n coll))\n  ([n step coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (let [p (doall (take n s))]\n           (when (= n (count p))\n             (cons p (partition n step (nthrest s step))))))))\n  ([n step pad coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (let [p (doall (take n s))]\n           (if (= n (count p))\n             (cons p (partition n step pad (nthrest s step)))\n             (list (take n (concat p pad)))))))))", :column 1, :line 3176, :arglists ([n coll] [n step coll] [n step pad coll]), :doc "Returns a lazy sequence of lists of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition upto n items. In case there are\n  not enough padding elements, return a partition with less than n items.", :namespace "clojure.core"}