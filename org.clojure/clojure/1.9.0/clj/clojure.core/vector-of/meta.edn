{:added "1.2", :ns #object[clojure.lang.Namespace 0x264888e7 "clojure.core"], :name "vector-of", :file "clojure/gvec.clj", :type :fn, :src "(defn vector-of\n  \"Creates a new vector of a single primitive type t, where t is one\n  of :int :long :float :double :byte :short :char or :boolean. The\n  resulting vector complies with the interface of vectors in general,\n  but stores the values unboxed internally.\n\n  Optionally takes one or more elements to populate the vector.\"\n  {:added \"1.2\"\n   :arglists '([t] [t & elements])}\n  ([t]\n   (let [^clojure.core.ArrayManager am (ams-check t)]\n     (Vec. am 0 5 EMPTY-NODE (.array am 0) nil)))\n  ([t x1]\n   (let [^clojure.core.ArrayManager am (ams-check t)\n         arr (.array am 1)]\n     (.aset am arr 0 x1)\n     (Vec. am 1 5 EMPTY-NODE arr nil)))\n  ([t x1 x2]\n   (let [^clojure.core.ArrayManager am (ams-check t)\n         arr (.array am 2)]\n     (.aset am arr 0 x1)\n     (.aset am arr 1 x2)\n     (Vec. am 2 5 EMPTY-NODE arr nil)))\n  ([t x1 x2 x3]\n   (let [^clojure.core.ArrayManager am (ams-check t)\n         arr (.array am 3)]\n     (.aset am arr 0 x1)\n     (.aset am arr 1 x2)\n     (.aset am arr 2 x3)\n     (Vec. am 3 5 EMPTY-NODE arr nil)))\n  ([t x1 x2 x3 x4]\n   (let [^clojure.core.ArrayManager am (ams-check t)\n         arr (.array am 4)]\n     (.aset am arr 0 x1)\n     (.aset am arr 1 x2)\n     (.aset am arr 2 x3)\n     (.aset am arr 3 x4)\n     (Vec. am 4 5 EMPTY-NODE arr nil)))\n  ([t x1 x2 x3 x4 & xn]\n   (loop [v  (vector-of t x1 x2 x3 x4)\n          xn xn]\n     (if xn\n       (recur (conj v (first xn)) (next xn))\n       v))))", :column 1, :line 484, :arglists ([t] [t & elements]), :doc "Creates a new vector of a single primitive type t, where t is one\n  of :int :long :float :double :byte :short :char or :boolean. The\n  resulting vector complies with the interface of vectors in general,\n  but stores the values unboxed internally.\n\n  Optionally takes one or more elements to populate the vector.", :namespace "clojure.core"}