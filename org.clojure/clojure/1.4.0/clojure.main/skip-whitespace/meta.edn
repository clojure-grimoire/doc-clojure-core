{:type :fn, :src "(defn skip-whitespace\n  \"Skips whitespace characters on stream s. Returns :line-start, :stream-end,\n  or :body to indicate the relative location of the next character on s.\n  Interprets comma as whitespace and semicolon as comment to end of line.\n  Does not interpret #! as comment to end of line because only one\n  character of lookahead is available. The stream must either be an\n  instance of LineNumberingPushbackReader or duplicate its behavior of both\n  supporting .unread and collapsing all of CR, LF, and CRLF to a single\n  \\\\newline.\"\n  [s]\n  (loop [c (.read s)]\n    (cond\n     (= c (int \\newline)) :line-start\n     (= c -1) :stream-end\n     (= c (int \\;)) (do (.readLine s) :line-start)\n     (or (Character/isWhitespace (char c)) (= c (int \\,))) (recur (.read s))\n     :else (do (.unread s c) :body))))", :ns "clojure.main", :name "skip-whitespace", :arglists ([s]), :doc "Skips whitespace characters on stream s. Returns :line-start, :stream-end,\n  or :body to indicate the relative location of the next character on s.\n  Interprets comma as whitespace and semicolon as comment to end of line.\n  Does not interpret #! as comment to end of line because only one\n  character of lookahead is available. The stream must either be an\n  instance of LineNumberingPushbackReader or duplicate its behavior of both\n  supporting .unread and collapsing all of CR, LF, and CRLF to a single\n  \\newline.", :line 127, :file "clojure/main.clj"}