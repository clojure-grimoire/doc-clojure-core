{:type :fn, :src "(defn bean\n  \"Takes a Java object and returns a read-only implementation of the\n  map abstraction based upon its JavaBean properties.\"\n  {:added \"1.0\"}\n  [^Object x]\n  (let [c (. x (getClass))\n\tpmap (reduce1 (fn [m ^java.beans.PropertyDescriptor pd]\n\t\t\t (let [name (. pd (getName))\n\t\t\t       method (. pd (getReadMethod))]\n\t\t\t   (if (and method (zero? (alength (. method (getParameterTypes)))))\n\t\t\t     (assoc m (keyword name) (fn [] (clojure.lang.Reflector/prepRet (.getPropertyType pd) (. method (invoke x nil)))))\n\t\t\t     m)))\n\t\t     {}\n\t\t     (seq (.. java.beans.Introspector\n\t\t\t      (getBeanInfo c)\n\t\t\t      (getPropertyDescriptors))))\n\tv (fn [k] ((pmap k)))\n        snapshot (fn []\n                   (reduce1 (fn [m e]\n                             (assoc m (key e) ((val e))))\n                           {} (seq pmap)))]\n    (proxy [clojure.lang.APersistentMap]\n           []\n      (containsKey [k] (contains? pmap k))\n      (entryAt [k] (when (contains? pmap k) (new clojure.lang.MapEntry k (v k))))\n      (valAt ([k] (v k))\n\t     ([k default] (if (contains? pmap k) (v k) default)))\n      (cons [m] (conj (snapshot) m))\n      (count [] (count pmap))\n      (assoc [k v] (assoc (snapshot) k v))\n      (without [k] (dissoc (snapshot) k))\n      (seq [] ((fn thisfn [plseq]\n\t\t  (lazy-seq\n                   (when-let [pseq (seq plseq)]\n                     (cons (new clojure.lang.MapEntry (first pseq) (v (first pseq)))\n                           (thisfn (rest pseq)))))) (keys pmap))))))", :ns "clojure.core", :name "bean", :arglists ([x]), :added "1.0", :doc "Takes a Java object and returns a read-only implementation of the\n  map abstraction based upon its JavaBean properties.", :line 372, :file "clojure/core_proxy.clj"}