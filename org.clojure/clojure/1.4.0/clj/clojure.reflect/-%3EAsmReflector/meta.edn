{:type :fn, :src "(deftype AsmReflector [class-resolver]\n  Reflector\n  (do-reflect [_ typeref]\n    (with-open [is (resolve-class class-resolver typeref)]\n      (let [class-symbol (typesym typeref)\n            r (ClassReader. is)\n            result (atom {:bases #{} :flags #{} :members #{}})]\n        (.accept\n         r\n         (reify\n          ClassVisitor\n          (visit [_ version access name signature superName interfaces]\n                 (let [flags (parse-flags access :class)\n                       ;; ignore java.lang.Object on interfaces to match reflection\n                       superName (if (and (flags :interface)\n                                          (= superName \"java/lang/Object\"))\n                                   nil\n                                   superName)\n                       bases (->> (cons superName interfaces)\n                                  (remove nil?)\n                                  (map internal-name->class-symbol)\n                                  (map symbol)\n                                  (set)\n                                  (not-empty))]\n                   (swap! result merge {:bases bases \n                                        :flags flags})))\n          (visitSource [_ name debug])\n          (visitInnerClass [_ name outerName innerName access])\n          (visitField [_ access name desc signature value]\n                      (swap! result update-in [:members] (fnil conj #{})\n                             (Field. (symbol name)\n                                     (field-descriptor->class-symbol desc)\n                                     class-symbol\n                                     (parse-flags access :field)))\n                      nil)\n          (visitMethod [_ access name desc signature exceptions]\n                       (when-not (= name \"<clinit>\")\n                         (let [constructor? (= name \"<init>\")]\n                           (swap! result update-in [:members] (fnil conj #{})\n                                  (let [{:keys [parameter-types return-type]} (parse-method-descriptor desc)\n                                        flags (parse-flags access :method)]\n                                    (if constructor?\n                                      (Constructor. class-symbol\n                                                    class-symbol\n                                                    parameter-types\n                                                    (vec (map internal-name->class-symbol exceptions))\n                                                    flags)\n                                      (Method. (symbol name)\n                                               return-type\n                                               class-symbol\n                                               parameter-types\n                                               (vec (map internal-name->class-symbol exceptions))\n                                               flags))))))\n                       nil)\n          (visitEnd [_])\n          ) 0)\n        @result))))", :ns "clojure.reflect", :name "->AsmReflector", :arglists ([class-resolver]), :doc "Positional factory function for class clojure.reflect.AsmReflector.", :line 196, :file "clojure/reflect/java.clj"}