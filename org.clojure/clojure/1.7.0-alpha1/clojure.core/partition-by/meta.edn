{:added "1.2", :ns "clojure.core", :name "partition-by", :file "clojure/core.clj", :static true, :type :fn, :src "(defn partition-by\n  \"Applies f to each value in coll, splitting it each time f returns a\n   new value.  Returns a lazy seq of partitions.  Returns a stateful\n   transducer when no collection is provided.\"\n  {:added \"1.2\"\n   :static true}\n  ([f]\n  (fn [f1]\n    (let [a (java.util.ArrayList.)\n          pa (atom ::none)]\n      (fn\n        ([] (f1))\n        ([result]\n           (let [result (if (.isEmpty a)\n                          result\n                          (let [v (vec (.toArray a))]\n                            ;;flushing ops must clear before invoking possibly\n                            ;;failing nested op, else infinite loop\n                            (.clear a)\n                            (f1 result v)))]\n             (f1 result)))\n        ([result input]\n           (let [pval @pa\n                 val (f input)]\n             (reset! pa val)\n             (if (or (identical? pval ::none)\n                     (= val pval))\n               (do\n                 (.add a input)\n                 result)\n               (let [v (vec (.toArray a))]\n                 (.clear a)\n                 (.add a input)\n                 (f1 result v)))))))))\n  ([f coll]\n     (lazy-seq\n      (when-let [s (seq coll)]\n        (let [fst (first s)\n              fv (f fst)\n              run (cons fst (take-while #(= fv (f %)) (next s)))]\n          (cons run (partition-by f (seq (drop (count run) s)))))))))", :column 1, :line 6737, :arglists ([f] [f coll]), :doc "Applies f to each value in coll, splitting it each time f returns a\n   new value.  Returns a lazy seq of partitions.  Returns a stateful\n   transducer when no collection is provided."}