{:added "1.7", :ns "clojure.core", :name "transduce", :file "clojure/core.clj", :type :fn, :src "(defn transduce\n  \"reduce with a transformation of f (xf). If init is not\n  supplied, (f) will be called to produce it. Returns the result of\n  applying (the transformed) xf to init and the first item in coll,\n  then applying xf to that result and the 2nd item, etc. If coll\n  contains no items, returns init and f is not called. Note that\n  certain transforms may inject or skip items.\"\n  {:added \"1.7\"}\n  ([xform f coll] (transduce xform f (f) coll))\n  ([xform f init coll]\n     (let [f (xform (completing f))\n           ret (if (instance? clojure.lang.IReduce coll)\n                 (.reduce ^clojure.lang.IReduce coll f init)\n                 (clojure.core.protocols/coll-reduce coll f init))\n           ret (f (if (reduced? ret) @ret ret))]\n       (if (reduced? ret) @ret ret))))", :column 1, :line 6446, :arglists ([xform f coll] [xform f init coll]), :doc "reduce with a transformation of f (xf). If init is not\n  supplied, (f) will be called to produce it. Returns the result of\n  applying (the transformed) xf to init and the first item in coll,\n  then applying xf to that result and the 2nd item, etc. If coll\n  contains no items, returns init and f is not called. Note that\n  certain transforms may inject or skip items."}