{:type :fn, :src "(deftype Vec [^clojure.core.ArrayManager am ^int cnt ^int shift ^clojure.core.VecNode root tail _meta]\n  Object\n  (equals [this o]\n    (cond \n     (identical? this o) true\n     (or (instance? clojure.lang.IPersistentVector o) (instance? java.util.RandomAccess o))\n       (and (= cnt (count o))\n            (loop [i (int 0)]\n              (cond\n               (= i cnt) true\n               (.equals (.nth this i) (nth o i)) (recur (inc i))\n               :else false)))\n     (or (instance? clojure.lang.Sequential o) (instance? java.util.List o))\n       (.equals (seq this) (seq o))\n     :else false))\n\n  ;todo - cache\n  (hashCode [this]\n    (loop [hash (int 1) i (int 0)]\n      (if (= i cnt)\n        hash\n        (let [val (.nth this i)]\n          (recur (unchecked-add-int (unchecked-multiply-int 31 hash) \n                                (clojure.lang.Util/hash val)) \n                 (inc i))))))\n\n  clojure.lang.Counted\n  (count [_] cnt)\n\n  clojure.lang.IMeta\n  (meta [_] _meta)\n\n  clojure.lang.IObj\n  (withMeta [_ m] (new Vec am cnt shift root tail m))\n\n  clojure.lang.Indexed\n  (nth [this i]\n    (let [a (.arrayFor this i)]\n      (.aget am a (bit-and i (int 0x1f)))))\n  (nth [this i not-found]\n       (let [z (int 0)]\n         (if (and (>= i z) (< i (.count this)))\n           (.nth this i)\n           not-found)))\n\n  clojure.lang.IPersistentCollection\n  (cons [this val]\n     (if (< (- cnt (.tailoff this)) (int 32))\n      (let [new-tail (.array am (inc (.alength am tail)))]\n        (System/arraycopy tail 0 new-tail 0 (.alength am tail))\n        (.aset am new-tail (.alength am tail) val)\n        (new Vec am (inc cnt) shift root new-tail (meta this)))\n      (let [tail-node (VecNode. (.edit root) tail)] \n        (if (> (bit-shift-right cnt (int 5)) (bit-shift-left (int 1) shift)) ;overflow root?\n          (let [new-root (VecNode. (.edit root) (object-array 32))]\n            (doto ^objects (.arr new-root)\n              (aset 0 root)\n              (aset 1 (.newPath this (.edit root) shift tail-node)))\n            (new Vec am (inc cnt) (+ shift (int 5)) new-root (let [tl (.array am 1)] (.aset am  tl 0 val) tl) (meta this)))\n          (new Vec am (inc cnt) shift (.pushTail this shift root tail-node) \n                 (let [tl (.array am 1)] (.aset am  tl 0 val) tl) (meta this))))))\n\n  (empty [_] (new Vec am 0 5 EMPTY-NODE (.array am 0) nil))                             \n  (equiv [this o]\n    (cond \n     (or (instance? clojure.lang.IPersistentVector o) (instance? java.util.RandomAccess o))\n       (and (= cnt (count o))\n            (loop [i (int 0)]\n              (cond\n               (= i cnt) true\n               (= (.nth this i) (nth o i)) (recur (inc i))\n               :else false)))\n     (or (instance? clojure.lang.Sequential o) (instance? java.util.List o))\n       (clojure.lang.Util/equiv (seq this) (seq o))\n     :else false))\n\n  clojure.lang.IPersistentStack\n  (peek [this]\n    (when (> cnt (int 0)) \n      (.nth this (dec cnt))))\n\n  (pop [this]\n   (cond\n    (zero? cnt) \n      (throw (IllegalStateException. \"Can't pop empty vector\"))\n    (= 1 cnt) \n      (new Vec am 0 5 EMPTY-NODE (.array am 0) (meta this))\n    (> (- cnt (.tailoff this)) 1)\n      (let [new-tail (.array am (dec (.alength am tail)))]\n        (System/arraycopy tail 0 new-tail 0 (.alength am new-tail))\n        (new Vec am (dec cnt) shift root new-tail (meta this)))\n    :else\n      (let [new-tail (.arrayFor this (- cnt 2))\n            new-root ^clojure.core.VecNode (.popTail this shift root)]\n        (cond\n         (nil? new-root) \n           (new Vec am (dec cnt) shift EMPTY-NODE new-tail (meta this))\n         (and (> shift 5) (nil? (aget ^objects (.arr new-root) 1)))\n           (new Vec am (dec cnt) (- shift 5) (aget ^objects (.arr new-root) 0) new-tail (meta this))\n         :else\n           (new Vec am (dec cnt) shift new-root new-tail (meta this))))))\n\n  clojure.lang.IPersistentVector\n  (assocN [this i val]\n    (cond \n     (and (<= (int 0) i) (< i cnt))\n       (if (>= i (.tailoff this))\n         (let [new-tail (.array am (.alength am tail))]\n           (System/arraycopy tail 0 new-tail 0 (.alength am tail))\n           (.aset am new-tail (bit-and i (int 0x1f)) val)\n           (new Vec am cnt shift root new-tail (meta this)))\n         (new Vec am cnt shift (.doAssoc this shift root i val) tail (meta this)))\n     (= i cnt) (.cons this val)\n     :else (throw (IndexOutOfBoundsException.))))\n  \n  clojure.lang.Reversible\n  (rseq [this]\n        (if (> (.count this) 0)\n          (clojure.lang.APersistentVector$RSeq. this (dec (.count this)))\n          nil))\n  \n  clojure.lang.Associative\n  (assoc [this k v]\n    (if (clojure.lang.Util/isInteger k)\n      (.assocN this k v)\n      (throw (IllegalArgumentException. \"Key must be integer\"))))\n  (containsKey [this k]\n    (and (clojure.lang.Util/isInteger k)\n         (<= 0 (int k))\n         (< (int k) cnt)))\n  (entryAt [this k]\n    (if (.containsKey this k)\n      (clojure.lang.MapEntry. k (.nth this (int k)))\n      nil))\n\n  clojure.lang.ILookup\n  (valAt [this k not-found]\n    (if (clojure.lang.Util/isInteger k)\n      (let [i (int k)]\n        (if (and (>= i 0) (< i cnt))\n          (.nth this i)\n          not-found))\n      not-found))\n\n  (valAt [this k] (.valAt this k nil))\n\n  clojure.lang.IFn\n  (invoke [this k]\n    (if (clojure.lang.Util/isInteger k)\n      (let [i (int k)]\n        (if (and (>= i 0) (< i cnt))\n          (.nth this i)\n          (throw (IndexOutOfBoundsException.))))\n      (throw (IllegalArgumentException. \"Key must be integer\"))))\n\n  \n  clojure.lang.Seqable\n  (seq [this] \n    (if (zero? cnt) \n      nil\n      (VecSeq. am this (.arrayFor this 0) 0 0)))\n\n  clojure.lang.Sequential ;marker, no methods\n\n  clojure.core.IVecImpl\n  (tailoff [_] \n    (- cnt (.alength am tail)))\n\n  (arrayFor [this i]\n    (if (and  (<= (int 0) i) (< i cnt))\n      (if (>= i (.tailoff this))\n        tail\n        (loop [node root level shift]\n          (if (zero? level)\n            (.arr node)\n            (recur (aget ^objects (.arr node) (bit-and (bit-shift-right i level) (int 0x1f))) \n                   (- level (int 5))))))\n      (throw (IndexOutOfBoundsException.))))\n\n  (pushTail [this level parent tailnode]\n    (let [subidx (bit-and (bit-shift-right (dec cnt) level) (int 0x1f))\n          parent ^clojure.core.VecNode parent\n          ret (VecNode. (.edit parent) (aclone ^objects (.arr parent)))\n          node-to-insert (if (= level (int 5))\n                           tailnode\n                           (let [child (aget ^objects (.arr parent) subidx)]\n                             (if child\n                               (.pushTail this (- level (int 5)) child tailnode)\n                               (.newPath this (.edit root) (- level (int 5)) tailnode))))]\n      (aset ^objects (.arr ret) subidx node-to-insert)\n      ret))\n\n  (popTail [this level node]\n    (let [node ^clojure.core.VecNode node\n          subidx (bit-and (bit-shift-right (- cnt (int 2)) level) (int 0x1f))]\n      (cond\n       (> level 5) \n         (let [new-child (.popTail this (- level 5) (aget ^objects (.arr node) subidx))]\n           (if (and (nil? new-child) (zero? subidx))\n             nil\n             (let [arr (aclone ^objects (.arr node))]\n               (aset arr subidx new-child)\n               (VecNode. (.edit root) arr))))\n       (zero? subidx) nil\n       :else (let [arr (aclone ^objects (.arr node))]\n               (aset arr subidx nil)\n               (VecNode. (.edit root) arr)))))\n\n  (newPath [this edit ^int level node]\n    (if (zero? level)\n      node\n      (let [ret (VecNode. edit (object-array 32))]\n        (aset ^objects (.arr ret) 0 (.newPath this edit (- level (int 5)) node))\n        ret)))\n\n  (doAssoc [this level node i val]\n    (let [node ^clojure.core.VecNode node]       \n      (if (zero? level)\n        ;on this branch, array will need val type\n        (let [arr (.aclone am (.arr node))]\n          (.aset am arr (bit-and i (int 0x1f)) val)\n          (VecNode. (.edit node) arr))\n        (let [arr (aclone ^objects (.arr node))\n              subidx (bit-and (bit-shift-right i level) (int 0x1f))]\n          (aset arr subidx (.doAssoc this (- level (int 5)) (aget arr subidx) i val))\n          (VecNode. (.edit node) arr)))))\n\n  java.lang.Comparable\n  (compareTo [this o]\n    (if (identical? this o)\n      0\n      (let [#^clojure.lang.IPersistentVector v (cast clojure.lang.IPersistentVector o)\n            vcnt (.count v)]\n        (cond\n          (< cnt vcnt) -1\n          (> cnt vcnt) 1\n          :else\n            (loop [i (int 0)]\n              (if (= i cnt)\n                0\n                (let [comp (clojure.lang.Util/compare (.nth this i) (.nth v i))]\n                  (if (= 0 comp)\n                    (recur (inc i))\n                    comp))))))))\n\n  java.lang.Iterable\n  (iterator [this]\n    (let [i (java.util.concurrent.atomic.AtomicInteger. 0)]\n      (reify java.util.Iterator\n        (hasNext [_] (< (.get i) cnt))\n        (next [_] (.nth this (dec (.incrementAndGet i))))\n        (remove [_] (throw (UnsupportedOperationException.))))))\n\n  java.util.Collection\n  (contains [this o] (boolean (some #(= % o) this)))\n  (containsAll [this c] (every? #(.contains this %) c))\n  (isEmpty [_] (zero? cnt))\n  (toArray [this] (into-array Object this))\n  (toArray [this arr]\n    (if (>= (count arr) cnt)\n      (do\n        (dotimes [i cnt]\n          (aset arr i (.nth this i)))\n        arr)\n      (into-array Object this)))\n  (size [_] cnt)\n  (add [_ o] (throw (UnsupportedOperationException.)))\n  (addAll [_ c] (throw (UnsupportedOperationException.)))\n  (clear [_] (throw (UnsupportedOperationException.)))\n  (^boolean remove [_ o] (throw (UnsupportedOperationException.)))\n  (removeAll [_ c] (throw (UnsupportedOperationException.)))\n  (retainAll [_ c] (throw (UnsupportedOperationException.)))\n\n  java.util.List\n  (get [this i] (.nth this i))\n  (indexOf [this o]\n    (loop [i (int 0)]\n      (cond\n        (== i cnt) -1\n        (= o (.nth this i)) i\n        :else (recur (inc i)))))\n  (lastIndexOf [this o]\n    (loop [i (dec cnt)]\n      (cond\n        (< i 0) -1\n        (= o (.nth this i)) i\n        :else (recur (dec i)))))\n  (listIterator [this] (.listIterator this 0))\n  (listIterator [this i]\n    (let [i (java.util.concurrent.atomic.AtomicInteger. i)]\n      (reify java.util.ListIterator\n        (hasNext [_] (< (.get i) cnt))\n        (hasPrevious [_] (pos? i))\n        (next [_] (.nth this (dec (.incrementAndGet i))))\n        (nextIndex [_] (.get i))\n        (previous [_] (.nth this (.decrementAndGet i)))\n        (previousIndex [_] (dec (.get i)))\n        (add [_ e] (throw (UnsupportedOperationException.)))\n        (remove [_] (throw (UnsupportedOperationException.)))\n        (set [_ e] (throw (UnsupportedOperationException.))))))\n  (subList [this a z] (subvec this a z))\n  (add [_ i o] (throw (UnsupportedOperationException.)))\n  (addAll [_ i c] (throw (UnsupportedOperationException.)))\n  (^Object remove [_ ^int i] (throw (UnsupportedOperationException.)))\n  (set [_ i e] (throw (UnsupportedOperationException.)))\n)", :ns "clojure.core", :name "->Vec", :arglists ([am cnt shift root tail _meta]), :column 1, :doc "Positional factory function for class clojure.core.Vec.", :line 122, :file "clojure/gvec.clj"}