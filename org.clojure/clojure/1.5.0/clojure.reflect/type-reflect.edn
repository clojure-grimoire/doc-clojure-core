{:arglists ([typeref & options]), :ns "clojure.reflect", :name "type-reflect", :src "(defn type-reflect\n  \"Alpha - subject to change.\n   Reflect on a typeref, returning a map with :bases, :flags, and\n  :members. In the discussion below, names are always Clojure symbols.\n\n   :bases            a set of names of the type's bases\n   :flags            a set of keywords naming the boolean attributes\n                     of the type.\n   :members          a set of the type's members. Each membrer is a map\n                     and can be a constructor, method, or field.\n\n   Keys common to all members:\n   :name             name of the type \n   :declaring-class  name of the declarer\n   :flags            keyword naming boolean attributes of the member\n\n   Keys specific to constructors:\n   :parameter-types  vector of parameter type names\n   :exception-types  vector of exception type names\n\n   Key specific to methods:\n   :parameter-types  vector of parameter type names\n   :exception-types  vector of exception type names\n   :return-type      return type name\n\n   Keys specific to fields:\n   :type             type name\n\n   Options:\n\n     :ancestors     in addition to the keys described above, also\n                    include an :ancestors key with the entire set of\n                    ancestors, and add all ancestor members to\n                    :members.\n     :reflector     implementation to use. Defaults to JavaReflector,\n                    AsmReflector is also an option.\"\n  {:added \"1.3\"}\n  [typeref & options]\n  (let [{:keys [ancestors reflector]}\n        (merge {:reflector default-reflector}\n               (apply hash-map options))\n        refl (partial do-reflect reflector)\n        result (refl typeref)]\n    ;; could make simpler loop of two args: names an\n    (if ancestors\n      (let [make-ancestor-map (fn [names]\n                            (zipmap names (map refl names)))]\n        (loop [reflections (make-ancestor-map (:bases result))]\n          (let [ancestors-visited (set (keys reflections))\n                ancestors-to-visit (set/difference (set (mapcat :bases (vals reflections)))\n                                               ancestors-visited)]\n            (if (seq ancestors-to-visit)\n              (recur (merge reflections (make-ancestor-map ancestors-to-visit)))\n              (apply merge-with into result {:ancestors ancestors-visited}\n                     (map #(select-keys % [:members]) (vals reflections)))))))\n      result)))", :column 1, :added "1.3", :type :fn, :doc "Alpha - subject to change.\n   Reflect on a typeref, returning a map with :bases, :flags, and\n  :members. In the discussion below, names are always Clojure symbols.\n\n   :bases            a set of names of the type's bases\n   :flags            a set of keywords naming the boolean attributes\n                     of the type.\n   :members          a set of the type's members. Each membrer is a map\n                     and can be a constructor, method, or field.\n\n   Keys common to all members:\n   :name             name of the type \n   :declaring-class  name of the declarer\n   :flags            keyword naming boolean attributes of the member\n\n   Keys specific to constructors:\n   :parameter-types  vector of parameter type names\n   :exception-types  vector of exception type names\n\n   Key specific to methods:\n   :parameter-types  vector of parameter type names\n   :exception-types  vector of exception type names\n   :return-type      return type name\n\n   Keys specific to fields:\n   :type             type name\n\n   Options:\n\n     :ancestors     in addition to the keys described above, also\n                    include an :ancestors key with the entire set of\n                    ancestors, and add all ancestor members to\n                    :members.\n     :reflector     implementation to use. Defaults to JavaReflector,\n                    AsmReflector is also an option.", :line 58, :file "clojure/reflect.clj"}