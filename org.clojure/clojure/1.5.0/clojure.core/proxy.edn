{:arglists ([class-and-interfaces args & fs]), :ns "clojure.core", :name "proxy", :src "(defmacro proxy\n  \"class-and-interfaces - a vector of class names\n\n  args - a (possibly empty) vector of arguments to the superclass\n  constructor.\n\n  f => (name [params*] body) or\n  (name ([params*] body) ([params+] body) ...)\n\n  Expands to code which creates a instance of a proxy class that\n  implements the named class/interface(s) by calling the supplied\n  fns. A single class, if provided, must be first. If not provided it\n  defaults to Object.\n\n  The interfaces names must be valid interface types. If a method fn\n  is not provided for a class method, the superclass methd will be\n  called. If a method fn is not provided for an interface method, an\n  UnsupportedOperationException will be thrown should it be\n  called. Method fns are closures and can capture the environment in\n  which proxy is called. Each method fn takes an additional implicit\n  first arg, which is bound to 'this. Note that while method fns can\n  be provided to override protected methods, they have no other access\n  to protected members, nor to super, as these capabilities cannot be\n  proxied.\"\n  {:added \"1.0\"}\n  [class-and-interfaces args & fs]\n   (let [bases (map #(or (resolve %) (throw (Exception. (str \"Can't resolve: \" %)))) \n                    class-and-interfaces)\n         [super interfaces] (get-super-and-interfaces bases)\n         compile-effect (when *compile-files*\n                          (let [[cname bytecode] (generate-proxy super interfaces)]\n                            (clojure.lang.Compiler/writeClassFile cname bytecode)))\n         pc-effect (apply get-proxy-class bases)\n         pname (proxy-name super interfaces)]\n     ;remember the class to prevent it from disappearing before use\n     (intern *ns* (symbol pname) pc-effect)\n     `(let [;pc# (get-proxy-class ~@class-and-interfaces)\n            p# (new ~(symbol pname) ~@args)] ;(construct-proxy pc# ~@args)]   \n        (init-proxy p#\n         ~(loop [fmap {} fs fs]\n            (if fs\n              (let [[sym & meths] (first fs)\n                    meths (if (vector? (first meths))\n                            (list meths)\n                            meths)\n                    meths (map (fn [[params & body]]\n                                   (cons (apply vector 'this params) body))\n                               meths)]\n                (if-not (contains? fmap (name sym))\t\t  \n                (recur (assoc fmap (name sym) (cons `fn meths)) (next fs))\n\t\t           (throw (IllegalArgumentException.\n\t\t\t              (str \"Method '\" (name sym) \"' redefined\")))))\n              fmap)))\n        p#)))", :column 1, :added "1.0", :type :macro, :doc "class-and-interfaces - a vector of class names\n\n  args - a (possibly empty) vector of arguments to the superclass\n  constructor.\n\n  f => (name [params*] body) or\n  (name ([params*] body) ([params+] body) ...)\n\n  Expands to code which creates a instance of a proxy class that\n  implements the named class/interface(s) by calling the supplied\n  fns. A single class, if provided, must be first. If not provided it\n  defaults to Object.\n\n  The interfaces names must be valid interface types. If a method fn\n  is not provided for a class method, the superclass methd will be\n  called. If a method fn is not provided for an interface method, an\n  UnsupportedOperationException will be thrown should it be\n  called. Method fns are closures and can capture the environment in\n  which proxy is called. Each method fn takes an additional implicit\n  first arg, which is bound to 'this. Note that while method fns can\n  be provided to override protected methods, they have no other access\n  to protected members, nor to super, as these capabilities cannot be\n  proxied.", :macro true, :line 303, :file "clojure/core_proxy.clj"}